#!/usr/bin/env bash

# Enable strict error handling
set -euo pipefail

# Global variables
readonly SCRIPT_NAME="git-code-review"
original_ref=""
review_branch=""
target_branch=""
user_command=""
should_stash=false

# Print usage information
usage() {
    cat << EOF
Usage: git code-review [branch] [target-branch] [--command <cmd>] [--stash]

Show commits in branch that are not in target-branch for code review

Arguments:
  [branch]         Branch to review (default: current branch)
  [target-branch]  Target branch to compare against (default: main/develop/master)
  --command <cmd>  Command to run when checking out a commit (optional)
  --stash          Stash changes made by command before returning to original ref (optional)

Keybindings:
  Enter/Return:    Checkout selected commit and run command (if specified)
  Alt+j/k:         Navigate preview
  Ctrl+f/b:        Page preview up/down
  q:               Quit without checkout

Examples:
  git code-review                                    # Review current branch vs main
  git code-review feature/new-ui                     # Review specific branch
  git code-review feature/api-changes develop        # Review against develop
  git code-review --command 'npm test'               # Review current branch with command
  git code-review feature/tests main --command 'npm test'
  git code-review feature/tests main --command 'npm test' --stash
EOF
    exit 1
}

# Print error message and exit
error_exit() {
    echo "Error: $1" >&2
    exit 1
}

# Check if required tools are available
check_dependencies() {
    local deps=("git" "sk" "bat")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            error_exit "Required tool '$dep' is not installed or not in PATH"
        fi
    done
}

# Get current branch name
get_current_branch() {
    git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD
}

# Auto-detect default target branch
get_default_target_branch() {
    local candidates=("develop" "main" "master")
    for branch in "${candidates[@]}"; do
        if git rev-parse --verify "$branch" >/dev/null 2>&1; then
            echo "$branch"
            return 0
        fi
    done
    error_exit "None of 'develop', 'main', or 'master' branches exist"
}

# Validate that a git reference exists
validate_git_ref() {
    local ref="$1"
    if ! git rev-parse --verify "$ref" >/dev/null 2>&1; then
        error_exit "Git reference '$ref' does not exist"
    fi
}

# Get number of commits to review
get_commits_count() {
    local target="$1"
    local review="$2"
    git rev-list --count "$target..$review" 2>/dev/null || error_exit "Failed to count commits between $target and $review"
}

# Store original reference for restoration
store_original_ref() {
    original_ref=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse HEAD)
    if [[ -z "$original_ref" ]]; then
        error_exit "Failed to determine current git reference"
    fi
}

# Execute user command safely
execute_user_command() {
    local cmd="$1"
    echo "Running command: $cmd"
    echo "----------------------------------------"
    # Use bash -c to execute the command safely
    if bash -c "$cmd"; then
        local exit_code=$?
        echo "----------------------------------------"
        echo "Command exit code: $exit_code"
        return $exit_code
    else
        local exit_code=$?
        echo "----------------------------------------"
        # Exit code 130 typically indicates the command was interrupted (e.g., Ctrl+C)
        # We'll treat this as a special case and continue execution
        if [[ $exit_code -eq 130 ]]; then
            echo "Command was interrupted (exit code 130), continuing..."
			return 0
        else
            echo "Command failed with exit code: $exit_code"
        fi
        return $exit_code
    fi
}

# Stash changes if needed
perform_stash() {
    if [[ "$should_stash" == true ]]; then
        if [[ -n "$(git status --porcelain 2>/dev/null)" ]]; then
            echo "Stashing changes made by command..."
            if git stash push -m "Code review stash for $original_ref" 2>/dev/null; then
                echo "Changes stashed successfully"
            else
                echo "Warning: Failed to stash changes"
            fi
        else
            echo "No changes to stash"
        fi
    fi
}

# Checkout commit and run command
checkout_and_run() {
    local commit_hash="$1"

    echo "Checking out commit: $commit_hash"

    if ! git checkout "$commit_hash" 2>/dev/null; then
        error_exit "Failed to checkout commit $commit_hash"
    fi

    if [[ -n "$user_command" ]]; then
        execute_user_command "$user_command"
    fi

    perform_stash

    echo "Returning to: $original_ref"
    if ! git checkout "$original_ref" 2>/dev/null; then
        error_exit "Failed to return to original reference: $original_ref"
    fi
}

# Main function
main() {
    # Check dependencies first
    check_dependencies

    # Parse command line arguments
    local temp_branch=""
    local temp_target=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                ;;
            --command)
                if [[ -n "${2:-}" ]]; then
                    user_command="$2"
                    shift 2
                else
                    error_exit "--command requires an argument"
                fi
                ;;
            --stash)
                should_stash=true
                shift
                ;;
            --*)
                error_exit "Unknown option: $1"
                ;;
            *)
                if [[ -z "$temp_branch" ]]; then
                    temp_branch="$1"
                elif [[ -z "$temp_target" ]]; then
                    temp_target="$1"
                else
                    error_exit "Unexpected argument: $1"
                fi
                shift
                ;;
        esac
    done

    # Determine review branch
    if [[ -n "$temp_branch" ]]; then
        review_branch="$temp_branch"
    else
        review_branch=$(get_current_branch)
        if [[ $? -ne 0 ]]; then
            error_exit "Cannot determine current branch"
        fi
    fi

    # Determine target branch
    if [[ -n "$temp_target" ]]; then
        target_branch="$temp_target"
    else
        target_branch=$(get_default_target_branch)
    fi

    # Validate git references
    validate_git_ref "$review_branch"
    validate_git_ref "$target_branch"

    # Get number of commits to review
    local commits_to_review
    commits_to_review=$(get_commits_count "$target_branch" "$review_branch")

    if [[ "$commits_to_review" -eq 0 ]]; then
        echo "No commits to review in '$review_branch' that are not in '$target_branch'"
        exit 0
    fi

    # Store original reference
    store_original_ref

    # Display review information
    echo "Code Review: $review_branch vs $target_branch ($commits_to_review commits)"
    if [[ -n "$user_command" ]]; then
        echo "Command to run: $user_command"
    fi
    if [[ "$should_stash" == true ]]; then
        echo "Stashing changes after command execution"
    fi
    echo ""

    # Main loop for continuous selection
    while true; do
        # Use a temporary file to avoid potential issues with pipes
        local temp_log_file
        temp_log_file=$(mktemp)

        # Generate the git log output
        git log \
            --no-merges --graph --color=always --abbrev=7 \
            --format='%C(auto)%h %an %C(blue)%s %C(yellow)%cr' \
            "$target_branch..$review_branch" > "$temp_log_file" 2>/dev/null

        # Use sk to select a commit
        local selected_commit
        selected_commit=$(sk \
            --ansi --no-sort --reverse --tiebreak=index \
            --header="Code Review: $review_branch vs $target_branch (Enter=checkout+run, q=quit)" \
            --preview "echo '{}' | sed 's/.*\\([a-f0-9]\\{7\\}\\).*/\\1/' | xargs -I {} git show --color=always {} | bat -l git" \
            --bind "alt-j:preview-down,alt-k:preview-up,ctrl-f:preview-page-down,ctrl-b:preview-page-up,q:abort" \
            --preview-window=right:70% < "$temp_log_file" 2>/dev/null || true)

        # Clean up temporary file
        rm -f "$temp_log_file"

        if [[ -n "$selected_commit" ]]; then
            # Extract commit hash safely
            local commit_hash
            commit_hash=$(echo "$selected_commit" | sed -E 's/.*([a-f0-9]{7}).*/\1/' | head -c 7)

            # Validate commit hash format
            if [[ ! "$commit_hash" =~ ^[a-f0-9]{7}$ ]]; then
                echo "Warning: Invalid commit hash extracted: $commit_hash" >&2
                continue
            fi

            checkout_and_run "$commit_hash"
        else
            # User pressed 'q' to quit or no selection was made
            break
        fi
    done

    echo "Exiting code review."
}

# Run main function with all arguments
main "$@"
